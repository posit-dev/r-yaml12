[{"path":"https://posit-dev.github.io/r-yaml12/dev/AGENTS.html","id":null,"dir":"","previous_headings":"","what":"Agent Instructions","title":"Agent Instructions","text":"Don’t hand-edit generated artifacts: man/, NAMESPACE, R/extendr-wrappers.R. Unless explicitly asked, never touch Makevars files. Never change vendor resolve Rust crates. Read-git commands (status/diff/log) always fine; never stage, unstage, commit, otherwise change git state unless explicitly asked. Don’t ask permission make file edits—just work share results ’s ready review. roxygen Rust doc comments change, regenerate docs/wrappers package root : rextendr::document(); devtools::document(). add/remove exports otherwise change Rd-facing surface (including new internal exports), always rerun rextendr::document(); devtools::document() finishing task. wrapping , run formatters: cargo fmt air format .. working Rust code, prefer iterate switching src/rust directory running cargo check . finish making edits, run cargo clippy address issues. finished making edits Rust files, run cargo fmt cargo build. Rust, avoid allocating String unnecessarily. Prefer working &str slices borrow directly raw input buffer, preserving lifetimes original input, allocate/clone String truly need owned data. format strings, always inline expressions (e.g., \"{foo}\" \"{foo:?}\"). Run R tests Rscript -e 'devtools::test()' (bare, cd expressions). start request requires code edits, first thing ask run Rscript -e 'devtools::test()' elevated permissions—never prefix cd. prefer iterate running full test suite command. Use timeout least 5 minutes test() 8 minutes check(). Deviating cause build failures related vendor .cargo, /sandbox restrictions. Run small experiments frequently confirm behavior language features. small experiments require elevated privileges run, write script scratch/experiments.R, ask elevated permissions run R -q -f scratch/experiments.R. every set changes, emit draft commit message. asked revisions, ’re done, emit updated draft commit message. Always run full test suite (Rscript -e 'devtools::test()') changes without asking whether .","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 yaml12 authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"goal","dir":"Articles","previous_headings":"","what":"Goal","title":"Benchmarks","text":"Compare yaml12 yaml reading writing YAML range document sizes. intentionally avoid testing semantic differences YAML 1.1 1.2, well less-used YAML features like tags streams. Instead, focus simple default usage . Operations: read: YAML file → R object write: R object → YAML (written nullfile())","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"setup","dir":"Articles","previous_headings":"","what":"Setup","title":"Benchmarks","text":"","code":"library(dplyr, warn.conflicts = FALSE) library(ggplot2)"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"generate-inputs","dir":"Articles","previous_headings":"Setup","what":"Generate inputs","title":"Benchmarks","text":"benchmark, create YAML files consisting repeating sequence small, fixed “mixed” node, repeated 2^(1:15) times. node designed exercise full YAML 1.2 core schema (every core type represented). generate files yaml12::write_yaml(). file written temporary file measure read time. Note macOS Linux, tempfile() paths often live tmpfs RAM, typically won’t trigger write disk circumstances.","code":"# A YAML node that exercises every core schema type: #   seq, map, str, bool, int, float, null mixed_node <- list(   str = c(     \"Lorem ipsum dolor sit amet, vel accumsan vitae faucibus ultrices leo\",     \"neque? Et cursus lacinia, ut, sit donec facilisi eu interdum. Dui\",     \"ipsum, vitae ligula commodo convallis ac sed nunc. Ipsum at nec lacus\",     \"eros suscipit vitae.\"   ),   block_str = \"lorem \\n ipsum \\n dolor\\n\",   bools = c(TRUE, FALSE),   ints = c(123L, -123L),   floats = c(123.456, -123.456),   null = NULL ) make_yaml_doc <- function(size = 1) {   path <- tempfile(fileext = \".yaml\")   yaml12::write_yaml(rep(list(mixed_node), size), path)   path }  docs <- sapply(2^(1:15), make_yaml_doc)"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"read-performance","dir":"Articles","previous_headings":"","what":"Read performance","title":"Benchmarks","text":"","code":"read_results <- lapply(docs, function(doc) {   result <- bench::mark(     yaml12::read_yaml(doc),     yaml::read_yaml(doc),     check = FALSE   )   result$file_size <- file.info(doc)$size   result }) #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled. #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled. #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled."},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"read-results-summary","dir":"Articles","previous_headings":"Read performance","what":"Read results summary","title":"Benchmarks","text":"","code":"read_results_df <- bind_rows(read_results) |>   mutate(expression = as.factor(sapply(expression, deparse1))) read_results_df |>   ggplot(aes(x = file_size, y = median, color = expression)) +   labs(     y = \"Median Run Time\",     x = \"File Size\",     title = \"Read Performance\"   ) +   geom_point() +   geom_smooth(linewidth = .5) +   scale_x_log10(labels = scales::label_bytes()) +   scale_y_continuous(trans = bench::bench_time_trans()) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"read-results-detailed","dir":"Articles","previous_headings":"Read performance","what":"Read results (detailed)","title":"Benchmarks","text":"","code":"invisible(lapply(read_results, \\(result) {   print(plot(result) + ggplot2::ggtitle(scales::label_bytes()(result$file_size[1])))   print(summary(result, filter_gc = FALSE)) })) #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…       856  33.8µs  35.4µs    25211.     2.6KB     2.52 #> 2 yaml::read_ya…       856   101µs 105.5µs     8800.    34.8KB    16.0  #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…      1704  59.5µs  62.8µs    15509.        0B     2.00 #> 2 yaml::read_ya…      1704 145.5µs 164.2µs     5097.    10.9KB     6.00 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  file_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>      <dbl> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::re…      3400 113µs  119µs     8262.        0B     0     4130 #> 2 yaml::read…      3400 233µs  244µs     3971.    13.7KB     4.00  1986 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  file_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>      <dbl> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::re…      6792 226µs  238µs     4116.        0B     0     2058 #> 2 yaml::read…      6792 412µs  429µs     2293.    19.4KB     4.00  1147 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  file_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>      <dbl> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::re…     13576 462µs  480µs     2068.      304B     0     1034 #> 2 yaml::read…     13576 767µs  794µs     1234.    31.1KB     3.99   618 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression   file_size      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>       <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::rea…     27144 924.49µs 949.44µs     1048.      560B     0    #> 2 yaml::read_…     27144   1.52ms   1.54ms      635.    69.8KB     3.99 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression file_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>     <dbl> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::r…     54280 1.85ms 1.89ms      523.    1.05KB     2.00   262 #> 2 yaml::rea…     54280 3.07ms  3.1ms      311.  147.06KB     3.96   157 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression file_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>     <dbl> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::r…    108552 3.59ms 3.71ms      268.    2.05KB     0      135 #> 2 yaml::rea…    108552 6.55ms 6.66ms      147.   301.6KB     3.99    74 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…    217096  7.19ms  7.26ms     137.     4.05KB     0    #> 2 yaml::read_ya…    217096 15.68ms 15.85ms      62.5  610.65KB     1.95 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression file_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>     <dbl> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::r…    434184 14.2ms 14.3ms      69.5    8.05KB     0       35 #> 2 yaml::rea…    434184 41.4ms   42ms      23.5     1.2MB     1.96    12 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      file_size     min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>          <dbl> <bch:t> <bch:>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_y…    868360  27.6ms   28ms     35.0    16.05KB     1.94 #> 2 yaml::read_yam…    868360 138.4ms  142ms      7.04    2.41MB     0    #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…   1736712  56.6ms  57.8ms     16.7    32.05KB        0 #> 2 yaml::read_ya…   1736712 838.5ms 838.5ms      1.19    4.82MB        0 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression   file_size      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>       <dbl> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::rea…   3473416 116.23ms 118.32ms     8.26    64.05KB    1.65  #> 2 yaml::read_…   3473416    4.13s    4.13s     0.242    9.65MB    0.242 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…   6946824 244.6ms 251.1ms    3.98       128KB    1.99  #> 2 yaml::read_ya…   6946824   17.3s   17.3s    0.0579    19.3MB    0.116 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     file_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>         <dbl> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::read_…  13893640 477.1ms 486.7ms    2.05       256KB   0      #> 2 yaml::read_ya…  13893640   57.4s   57.4s    0.0174    38.6MB   0.0523 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list>"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"write-performance","dir":"Articles","previous_headings":"","what":"Write performance","title":"Benchmarks","text":"","code":"objs <- lapply(2^(1:15), function(n) rep(list(mixed_node), n))  write_results <- lapply(objs, function(obj) {   result <- bench::mark(     yaml12::write_yaml(obj, nullfile()),     yaml::write_yaml(obj, nullfile()),     check = FALSE   )   result$obj_size <- object.size(obj)   result }) #> Warning: Some expressions had a GC in every iteration; so filtering is #> disabled."},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"write-results-summary","dir":"Articles","previous_headings":"Write performance","what":"Write results summary:","title":"Benchmarks","text":"","code":"write_results_df <- bind_rows(write_results) |>   mutate(expression = as.factor(sapply(expression, deparse1))) write_results_df |>   ggplot(aes(x = obj_size, y = median, color = expression)) +   labs(     y = \"Median Run Time\",     x = \"Object Size\",     title = \"Write Performance\"   ) +   geom_point() +   geom_smooth(linewidth = .5) +   scale_x_log10(labels = scales::label_bytes()) +   scale_y_continuous(trans = bench::bench_time_trans()) #> `geom_smooth()` using method = 'loess' and formula = 'y ~ x'"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"write-results-detailed","dir":"Articles","previous_headings":"Write performance","what":"Write results (detailed)","title":"Benchmarks","text":"","code":"invisible(lapply(write_results, \\(result) {   print(plot(result) + ggplot2::ggtitle(scales::label_bytes()(as.numeric(result$obj_size[1]))))   print(summary(result, filter_gc = FALSE)) })) #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 3360 by… 15.5µs 16.2µs    60666.    3.02KB     0    10000 #> 2 yaml::writ… 3360 by… 69.8µs   73µs    12585.   33.67KB     2.00  6290 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 6672 by… 24.1µs 25.1µs    39219.        0B     0    10000 #> 2 yaml::writ… 6672 by… 91.2µs 95.6µs     9836.    1.56KB     4.00  4917 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      obj_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>      <objct_> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write_… 13296 b…  42.7µs  44.4µs    22185.        0B     0    #> 2 yaml::write_ya… 13296 b… 135.7µs   141µs     6799.    3.07KB     2.00 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      obj_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>      <objct_> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write_… 26544 b…  78.4µs  81.7µs    12020.        0B     0    #> 2 yaml::write_ya… 26544 b… 221.3µs   230µs     4200.    6.09KB     2.00 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression   obj_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>   <objct_> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wri… 53040 b… 155µs  163µs     6050.        0B     0     3025 #> 2 yaml::write… 53040 b… 405µs  425µs     2275.    12.1KB     4.00  1138 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression   obj_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>   <objct_> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wri… 106032 … 308µs  320µs     3103.        0B     0     1552 #> 2 yaml::write… 106032 … 768µs  796µs     1228.    24.2KB     2.00   615 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression     obj_size     min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>     <objct_> <bch:t> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write… 212016 … 617.7µs 638.18µs     1565.        0B     0    #> 2 yaml::write_y… 212016 …   1.5ms   1.54ms      628.    48.3KB     3.99 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 423984 … 1.21ms 1.24ms      807.        0B     0      404 #> 2 yaml::writ… 423984 … 2.93ms    3ms      325.    96.6KB     1.99   163 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 847920 … 2.37ms  2.4ms      417.        0B     0      209 #> 2 yaml::writ… 847920 … 5.86ms 5.95ms      164.     193KB     1.98    83 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      obj_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>      <objct_> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write_… 1695792…  4.62ms  4.68ms     213.         0B     0    #> 2 yaml::write_ya… 1695792… 11.71ms 11.88ms      81.3     386KB     3.96 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      obj_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>      <objct_> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write_… 3391536…  9.07ms  9.15ms     109.         0B     0    #> 2 yaml::write_ya… 3391536… 23.32ms 23.75ms      41.4     772KB     1.97 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 6783024… 18.1ms 18.3ms      54.6        0B     0       28 #> 2 yaml::writ… 6783024…   47ms 47.6ms      20.4    1.51MB     3.71    11 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression  obj_size    min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>  <objct_> <bch:> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wr… 1356600… 36.3ms 38.8ms     26.0         0B     0       14 #> 2 yaml::writ… 1356600… 94.4ms 95.3ms      9.90    3.02MB     1.98     5 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression      obj_size     min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>      <objct_> <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 yaml12::write_… 2713195…  79.3ms  80.3ms     12.5         0B     0    #> 2 yaml::write_ya… 2713195… 192.9ms 199.2ms      5.07    6.03MB     3.38 #> # ℹ 7 more variables: n_itr <int>, n_gc <dbl>, total_time <bch:tm>, #> #   result <list>, memory <list>, time <list>, gc <list> #> # A tibble: 2 × 14 #>   expression   obj_size   min median `itr/sec` mem_alloc `gc/sec` n_itr #>   <bch:expr>   <objct_> <bch> <bch:>     <dbl> <bch:byt>    <dbl> <int> #> 1 yaml12::wri… 5426385… 166ms  166ms      5.98        0B     0        3 #> 2 yaml::write… 5426385… 379ms  380ms      2.63    12.1MB     2.63     2 #> # ℹ 6 more variables: n_gc <dbl>, total_time <bch:tm>, result <list>, #> #   memory <list>, time <list>, gc <list>"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/benchmarks.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Benchmarks","text":"Across tested file sizes workload, yaml12 faster yaml reading writing YAML.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"a-first-example","dir":"Articles","previous_headings":"","what":"A first example","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"","code":"title: A Modern YAML parser written in Rust properties: [correct, safe, fast, simple] score: 9.5 categories:   - yaml   - r   - example settings:   simplify: true   note: >     This is a folded block     that turns line breaks     into spaces.   note_literal: |     This is a literal block     that keeps     line breaks. str(parse_yaml(first_example)) #> List of 5 #>  $ title     : chr \"A Modern YAML parser written in Rust\" #>  $ properties: chr [1:4] \"correct\" \"safe\" \"fast\" \"simple\" #>  $ score     : num 9.5 #>  $ categories: chr [1:3] \"yaml\" \"r\" \"example\" #>  $ settings  :List of 3 #>   ..$ simplify    : logi TRUE #>   ..$ note        : chr \"This is a folded block that turns line breaks into spaces.\\n\" #>   ..$ note_literal: chr \"This is a literal block\\nthat keeps\\nline breaks.\\n\""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"comments","dir":"Articles","previous_headings":"","what":"Comments","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"Comments start # run end line. must separated values whitespace can sit line line ends; ignored parser. → list(title = \"example\", items = c(\"\", \"b\"))","code":"# Whole-line comment title: example # inline comment items: [a, b] # trailing comment"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"collections","dir":"Articles","previous_headings":"","what":"Collections","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"two “collection” types: Sequences Mappings.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"sequences-yamls-ordered-collections","dir":"Articles","previous_headings":"Collections","what":"Sequences: YAML’s ordered collections","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"sequence list items. item begins - parent indent. → c(\"cat\", \"dog\") (list(\"cat\", \"dog\") simplify = FALSE) JSON-style arrays work : → result Anything belonging one sequence entries indented least one space past dash: ↓","code":"- cat - dog [cat, dog] - name: cat   toys: [string, box] - name: dog   toys: [ball, bone] list(   list(name = \"cat\", toys = c(\"string\", \"box\")),   list(name = \"dog\", toys = c(\"ball\", \"bone\")) )"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"mappings-keyvalue-pairs","dir":"Articles","previous_headings":"Collections","what":"Mappings: key/value pairs","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"mapping set key: value pairs indent: → list(foo = 1L, bar = TRUE) key indent owns anything indented : → list(settings = list(simplify = TRUE, max_items = 3L)) JSON-style objects also work: → list(= TRUE) Mappings become named lists R.","code":"foo: 1 bar: true settings:   simplify: true   max_items: 3 {a: true}"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"scalars","dir":"Articles","previous_headings":"","what":"Scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"nodes collections Scalars; leaf nodes YAML document. Scalars can provided three forms: block, quoted, plain.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"block-scalars","dir":"Articles","previous_headings":"Scalars","what":"Block scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"| starts literal block keeps newlines; > starts folded block joins lines spaces (except blank/indented lines keep breaks). Block scalars always become strings. → \"hello\\nworld\\n\" → \"hello world\\n\"","code":"|   hello   world >   hello   world"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"quoted-scalars","dir":"Articles","previous_headings":"","what":"Quoted scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"Like block scalars, quoted scalars always resolve strings. Double quotes interpret escapes (\\n, \\t, \\\\, \\\"). Single quotes literal interpret escapes, except '' parsed single '. → c(\"line\\nbreak\", 'quote: \"\"') → c(\"line\\\\nbreak\", \"quote: ''\")","code":"[\"line\\nbreak\", \"quote: \\\"here\\\"\"] ['line\\nbreak', 'quote: ''here''']"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"plain-unquoted-scalars","dir":"Articles","previous_headings":"","what":"Plain (unquoted) scalars","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"node sequence, mapping, block scalar, quoted scalar, plain scalar. Plain nodes can resolve one five types: string, int, float, bool, null. YAML 1.2 uses simple rules infer type plain node: true / false → TRUE / FALSE null, ~, empty → NULL numbers: signed, decimal, scientific, hex (0x), octal (0o), .inf, .nan → numeric() integer() everything else stays string (yes, , , aliases remain strings YAML 1.2) → list(TRUE, 123L, 450, 16L, Inf, \"yes\") sequence homogeneous simplify = TRUE, nulls become appropriate NA_* values.","code":"[true, 123, 4.5e2, 0x10, .inf, yes]"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"end-to-end-example","dir":"Articles","previous_headings":"","what":"End-to-end example","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"R result (parse_yaml() defaults):","code":"doc:   pets:     - cat     - dog   numbers: [1, 2.5, 0x10, .inf, null]   integers: [1, 2, 3, 0x10, null]   flags: {enabled: true, label: on}   literal: |     hello     world   folded: >     hello     world   quoted:     - \"line\\nbreak\"     - 'quote: ''here'''   plain: [yes, no]   mixed: [won't simplify, 123, true] list(   doc = list(     pets = c(\"cat\", \"dog\"),     numbers = c(1, 2.5, 16, Inf, NA_real_),     integers = c(1L, 2L, 3L, 16L, NA_integer_),     flags = list(enabled = TRUE, label = \"on\"),     literal = \"hello\\nworld\\n\",     folded = \"hello world\\n\",     quoted = c(\"line\\nbreak\", \"quote: 'here'\"),     plain = c(\"yes\", \"no\"),     mixed = list(\"won't simplify\", 123L, TRUE)   ) )"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-2-minute-intro.html","id":"quick-notes","dir":"Articles","previous_headings":"","what":"Quick notes","title":"YAML in 2 Minutes: A Gentle Introduction for R Users","text":"Indentation defines structure collections. Sibling elements share indent, children indented . YAML 1.2 forbids tabs; use spaces. JSON valid YAML. Homogeneous sequences simplify vectors unless simplify = FALSE. Block scalars (|, >) always produce strings. Booleans true/false; null maps NULL (NA inside simplified vectors). essentials cover YAML ’ll run practice. encounter YAML tags non-string mapping keys, check “Advanced YAML” vignette.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"tags-in-yaml-and-how-yaml12-handles-them","dir":"Articles","previous_headings":"","what":"Tags in YAML and how yaml12 handles them","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"Tags annotate YAML node extra meaning. YAML syntax tag always starts !, appears node’s value; part scalar text . yaml12 attaches tags yaml_tag attribute (always string). common form simple local short tag starts !: presence custom tag bypasses normal scalar node type inference; scalar always returned string even content looks like another type.","code":"dput(parse_yaml(\"!some_tag some_value\")) #> structure(\"some_value\", yaml_tag = \"!some_tag\") parse_yaml(\"! true\") #> [1] \"true\" #> attr(,\"yaml_tag\") #> [1] \"!\" parse_yaml(\"true\") #> [1] TRUE"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"using-handlers-to-transform-tagged-nodes-while-parsing","dir":"Articles","previous_headings":"","what":"Using handlers to transform tagged nodes while parsing","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"parse_yaml() read_yaml() accept handlers: named list functions whose names YAML tag strings. Handlers run matching tagged node. tagged scalars, handler always receives length-1 string; tagged sequences mappings, receives R vector representing node. example using handler evaluate !expr nodes. errors handler stop parsing: tag without matching handler left preserved yaml_tag attribute, handlers without matching tags left unused. tagged sequence, handler called unnamed R list, atomic vector simplify = TRUE sequence elements common type. tagged mappings handler called named R list, potentially yaml_keys attribute (next section). Handlers make easy opt powerful behaviors (like evaluating !expr nodes) keeping default parser strict safe.","code":"handlers <- list(   \"!expr\" = function(x) eval(str2lang(x), globalenv()) ) parse_yaml(\"!expr 1+1\", handlers = handlers) #> [1] 2 parse_yaml(\"!expr stop('boom')\", handlers = handlers) #> Error in eval(str2lang(x), globalenv()): boom handlers <- list(   \"!expr\" = function(x) eval(str2lang(x), globalenv()),   \"!upper\" = toupper,   \"!lower\" = tolower # unused )  str(parse_yaml(handlers = handlers, \" - !expr 1+1 - !upper r is awesome - !note this tag has no handler \")) #> List of 3 #>  $ : num 2 #>  $ : chr \"R IS AWESOME\" #>  $ : chr \"this tag has no handler\" #>   ..- attr(*, \"yaml_tag\")= chr \"!note\" handlers <- list(   \"!some_seq_tag\" = function(x) {     stopifnot(identical(x, c(\"a\", \"b\")))     \"some handled value\"   },   \"!some_map_tag\" = function(x) {     stopifnot(identical(x, list(key1 = 1L, key2 = 2L)))     \"some other handled value\"   } )  yaml_tagged_containers <- \" - !some_seq_tag [a, b] - !some_map_tag {key1: 1, key2: 2} \"  str(parse_yaml(yaml_tagged_containers, handlers = handlers)) #> List of 2 #>  $ : chr \"some handled value\" #>  $ : chr \"some other handled value\""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"post-process-tags-yourself","dir":"Articles","previous_headings":"Using handlers to transform tagged nodes while parsing","what":"Post-process tags yourself","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"want control, can parse first without handlers walk result . example, can process !expr-tagged scalars walking yaml nodes simply like :","code":"eval_yaml_expr_nodes <- function(x) {   if (is.list(x)) {     x <- lapply(x, eval_yaml_expr_nodes)   } else if (identical(attr(x, \"yaml_tag\", TRUE), \"!expr\")) {     x <- eval(str2lang(x), globalenv())   }   x }  safe_loaded <- parse_yaml(\"!expr 1 + 1\") dput(safe_loaded) #> structure(\"1 + 1\", yaml_tag = \"!expr\") eval_yaml_expr_nodes(safe_loaded) #> [1] 2"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"mappings-revisited-non-string-keys-and-yaml_keys","dir":"Articles","previous_headings":"","what":"Mappings revisited: non-string keys and yaml_keys","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML, mapping keys plain scalar strings; arbitrary YAML node can key: including scalar types, sequences, even mappings. example, valid YAML even though key boolean: yaml12 sees mapping key untagged string scalar, keeps original keys yaml_keys attribute next values: complex key values, YAML uses explicit mapping-key indicator ?. line starting ? introduces key node (type) mapping, following line starts : holds value: yaml12 can see keys via yaml_keys attribute:","code":"true: true dput(parse_yaml(\"true: true\")) #> structure(list(TRUE), names = \"\", yaml_keys = list(TRUE)) ? [a, b] : value with a sequence key ? {x: 1, y: 2} : value with a mapping key yaml <- \" true: true ? [a, b] : tuple ? {x: 1, y: 2} : map-key \"  str(parse_yaml(yaml)) #> List of 3 #>  $ : logi TRUE #>  $ : chr \"tuple\" #>  $ : chr \"map-key\" #>  - attr(*, \"yaml_keys\")=List of 3 #>   ..$ : logi TRUE #>   ..$ : chr [1:2] \"a\" \"b\" #>   ..$ :List of 2 #>   .. ..$ x: int 1 #>   .. ..$ y: int 2"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"tagged-mapping-keys","dir":"Articles","previous_headings":"Mappings revisited: non-string keys and yaml_keys","what":"Tagged mapping keys","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"supply handlers, run keys well, handler can turn tagged keys friendly R names yaml_keys needs attached. mapping keys resolve bare scalar strings, yaml_keys attribute attached. anticipate tagged mapping keys want process , ’ll need bit bookkeeping. yaml_keys attribute materialized whenever key plain, untagged string scalar; ’ll want walk keys alongside values optionally collapse yaml_keys back NULL keys become plain strings handling tagged nodes. example, earlier eval_yaml_expr_nodes expanded also handle tagged mapping keys. (expanded postprocessor equivalent passing handlers = list(\"!expr\" = \\(x) eval(str2lang(x), globalenv()))) control traversal, can add extra checks (example, allowing expressions certain mapping keys).","code":"handlers <- list(   \"!upper\" = toupper,   \"!airport\" = function(x) paste0(\"IATA:\", toupper(x)) )  yaml_tagged_key <- \" !upper newyork: !airport jfk !upper warsaw: !airport waw \"  str(parse_yaml(yaml_tagged_key, handlers = handlers)) #> List of 2 #>  $ NEWYORK: chr \"IATA:JFK\" #>  $ WARSAW : chr \"IATA:WAW\" is_bare_string <- \\(x) {   is.character(key) && length(key) == 1L && is.null(attributes(key)) }  eval_yaml_expr_nodes <- function(x) {   if (is.list(x)) {     x <- lapply(x, eval_yaml_expr_nodes)      if (!is.null(keys <- attr(x, \"yaml_keys\", TRUE))) {       keys <- lapply(keys, eval_yaml_expr_nodes)       names(x) <- sapply(         \\(name, key) if (name == \"\" && is_bare_string(key)) key else name,         names(x),         keys       )       attr(x, \"yaml_keys\") <-         if (all(sapply(keys, is_bare_string))) NULL else keys     }   }   if (identical(attr(x, \"yaml_tag\", TRUE), \"!expr\")) {     x <- eval(str2lang(x), globalenv())   }    x }"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"document-streams-and-markers","dir":"Articles","previous_headings":"","what":"Document Streams and Markers","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML files contain single YAML document. YAML also supports document streams, file string holds multiple YAML documents. Documents separated start marker (---) may optionally include end marker (...).","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"reading-multiple-documents","dir":"Articles","previous_headings":"Document Streams and Markers","what":"Reading Multiple Documents","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"reading functions (read_yaml(), parse_yaml()), multi argument defaults FALSE. mode, first YAML document read. end marker (...) new start marker (---) encountered, parser stops returns first document. multi = TRUE, documents stream returned.","code":"doc_stream <- \" --- doc 1 --- doc 2 \" parse_yaml(doc_stream) #> [1] \"doc 1\" parse_yaml(doc_stream, multi = TRUE) #> [[1]] #> [1] \"doc 1\" #>  #> [[2]] #> [1] \"doc 2\""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"writing-multiple-documents","dir":"Articles","previous_headings":"Document Streams and Markers","what":"Writing Multiple Documents","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"writing functions (write_yaml(), format_yaml()), multi also defaults FALSE, producing single YAML document. multi = TRUE, provided R object treated list documents written YAML document stream, documents separated start marker ---. Regardless multi, write_yaml() always includes initial start marker final end marker. multi = FALSE, parsing stops first document—even later content valid YAML. makes easy extract front matter files mix YAML text (like R Markdown): parser returns just YAML frontmatter second --- technically ends first YAML document YAML document stream; multi = FALSE parser stops returns just first YAML document.","code":"write_yaml(list(\"foo\", \"bar\")) #> --- #> - foo #> - bar #> ... write_yaml(list(\"foo\", \"bar\"), multi = TRUE) #> --- #> foo #> --- #> bar #> ... rmd_lines <- c(   \"---\",   \"title: Front matter only\",   \"params:\",   \"  answer: 42\",   \"---\",   \"# Body that is not YAML\" ) parse_yaml(rmd_lines) #> $title #> [1] \"Front matter only\" #>  #> $params #> $params$answer #> [1] 42"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"writing-yaml-with-tags","dir":"Articles","previous_headings":"","what":"Writing YAML with tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"emit tag, attach yaml_tag R value calling format_yaml() write_yaml().","code":"tagged <- structure(\"1 + x\", yaml_tag = \"!expr\") write_yaml(tagged) #> --- #> !expr 1 + x #> ..."},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"anchors","dir":"Articles","previous_headings":"","what":"Anchors","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"Anchors (&id) name node; aliases (*id) copy . yaml12 resolves aliases returning R objects.","code":"str(parse_yaml(\" recycle-me: &anchor-name   a: b   c: d  recycled:   - *anchor-name   - *anchor-name \")) #> List of 2 #>  $ recycle-me:List of 2 #>   ..$ a: chr \"b\" #>   ..$ c: chr \"d\" #>  $ recycled  :List of 2 #>   ..$ :List of 2 #>   .. ..$ a: chr \"b\" #>   .. ..$ c: chr \"d\" #>   ..$ :List of 2 #>   .. ..$ a: chr \"b\" #>   .. ..$ c: chr \"d\""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"debugging","dir":"Articles","previous_headings":"","what":"Debugging","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"want inspect YAML nodes parsed directly, can reach internal helper yaml12:::dbg_yaml() print raw (Rust) saphyr::Yaml structures without converting R objects.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"very-advanced-tags","dir":"Articles","previous_headings":"","what":"(Very) Advanced Tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"following YAML features rarely used, supported 100% compliance YAML 1.2 spec.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"tag-directives-tag","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"Tag directives (%TAG)","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"YAML lets declare tag handles top document %TAG directives. syntax %TAG !<name>! <handle>, applies rest document. !name! automatically expanded named tags: tag prefix !e! automatically expanded full form upon parsing. can also declare global tag prefix, expand bare “!”","code":"%TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo dput(parse_yaml(' %TAG !e! tag:example.com,2024:widgets/ --- item: !e!gizmo foo ')) #> list(item = structure(\"foo\", yaml_tag = \"tag:example.com,2024:widgets/gizmo\")) dput(parse_yaml(' %TAG ! tag:example.com,2024:widgets/ --- item: !gizmo foo ')) #> list(item = structure(\"foo\", yaml_tag = \"tag:example.com,2024:widgets/gizmo\"))"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"tag-uris","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"TAG URIs","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"two forms actually shorthands resolving tag “URI”. can bypass handle resolution using following tag syntax: !<...> Anything ... expanded, must valid URI (e.g., spaces must escaped, like URL).","code":"dput(parse_yaml(' %TAG ! tag:example.com,2024:widgets/ --- item: !<gizmo> foo ')) #> list(item = structure(\"foo\", yaml_tag = \"gizmo\"))"},{"path":"https://posit-dev.github.io/r-yaml12/dev/articles/yaml-tags-and-advanced-features.html","id":"core-schema-tags","dir":"Articles","previous_headings":"(Very) Advanced Tags","what":"Core schema tags","title":"YAML Tags, Anchors, and Advanced Features with yaml12","text":"may also encounter tags start two !!. special case !name!suffix tag syntax, name missing undefined implicitly resolved YAML Core schema handle: tag:yaml.org,2002:. following three tags resolve internal representation parse way: Core schema tags generally unnecessary since nodes resolved using core schema already. However, can alternative way declare node types. valid set core schema tags: map, seq, str, int, float, bool, null. Note YAML 1.2 removed built-types present YAML 1.1. !!pairs, !!omap, !!set, !!timestamp !!binary types dropped. Correspondingly, yaml12 formerly core tags come R unhandled tagged scalar, strings yaml_tag attribute. Note pairs, omap, set generally meaningful R, since R objects returned ordered (yaml12 automatically preserves order mapping entries). !!timestamp !!binary tags occasionally useful, logic handing richer types encouraged live application level, core schema. Note !!, parser expands first global prefix tag:yaml.org,2002: (unless tag directive changed meaning !!), tags come fully resolved core schema URI. can supply handler want convert character string R object:","code":"' - foo - !!str foo - !<tag:yaml.org,2002:str> foo ' |> parse_yaml() |> dput() #> c(\"foo\", \"foo\", \"foo\") yaml <- \" - !!timestamp 2025-01-01 - !!timestamp 2025-01-01 21:59:43.10 -5 - !!binary UiBpcyBBd2Vzb21l \" str(parse_yaml(yaml)) #> List of 3 #>  $ : chr \"2025-01-01\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:timestamp\" #>  $ : chr \"2025-01-01 21:59:43.10 -5\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:timestamp\" #>  $ : chr \"UiBpcyBBd2Vzb21l\" #>   ..- attr(*, \"yaml_tag\")= chr \"tag:yaml.org,2002:binary\" # Timestamp handler: Convert date-only into Date, otherwise try (some of) the # YAML 1.1 spec valid timestamp formats as POSIX formats. # return NA on failure. timestamp_handler <- function(x) {   stopifnot(is.character(x), length(x) == 1)   if (grepl(\"^\\\\d{4}-\\\\d{2}-\\\\d{2}$\", x)) {     return(as.Date(x))   }   formats <- c(     \"%Y-%m-%dT%H:%M:%OS%z\",     \"%Y-%m-%d %H:%M:%OS%z\",     \"%Y-%m-%dT%H:%M:%OS\",     \"%Y-%m-%d %H:%M:%OS\",     \"%Y-%m-%d %H:%M\"   )   as.POSIXct(x, tryFormats = formats, optional = TRUE) }  # Binary handler: decode Base64 into raw binary_handler <- function(x) {   stopifnot(is.character(x), length(x) == 1)   jsonlite::base64_dec(gsub(\"[ \\n]\", \"\", x)) } str(parse_yaml(yaml, handlers = list(   \"tag:yaml.org,2002:timestamp\" = timestamp_handler,   \"tag:yaml.org,2002:binary\" = binary_handler ))) #> List of 3 #>  $ : Date[1:1], format: \"2025-01-01\" #>  $ : POSIXct[1:1], format: \"2025-01-01 21:59:43\" #>  $ : raw [1:12] 52 20 69 73 ..."},{"path":"https://posit-dev.github.io/r-yaml12/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Tomasz Kalinowski. Author, maintainer. . Copyright holder, funder. Authors dependency Rust crates. Copyright holder.           See inst/AUTHORS LICENSE.note vendored Rust dependency authors licenses.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Kalinowski T (2025). yaml12: Fast 'YAML' 1.2 Parser Formatter. R package version 0.1.0.9000, https://posit-dev.github.io/r-yaml12/.","code":"@Manual{,   title = {yaml12: Fast 'YAML' 1.2 Parser and Formatter},   author = {Tomasz Kalinowski},   year = {2025},   note = {R package version 0.1.0.9000},   url = {https://posit-dev.github.io/r-yaml12/}, }"},{"path":"https://posit-dev.github.io/r-yaml12/dev/authors.html","id":null,"dir":"","previous_headings":"","what":"Additional details","title":"Authors and Citation","text":"","code":"Authors of vendored cargo crates  - arraydeque 0.5.1: andylokandy  - autocfg 1.5.0: Josh Stone  - cfg-if 1.0.4: Alex Crichton  - encoding_rs 0.8.35: Henri Sivonen  - extendr-api 0.8.1: andy-thomason, Thomas Down, Mossa Merhi Reimert, Josiah Parry, Claus O. Wilke, Hiroaki Yutani, Ilia A. Kosenkov, Michael Milton  - extendr-ffi 0.8.1: andy-thomason, Thomas Down, Mossa Merhi Reimert, Josiah Parry, Claus O. Wilke, Hiroaki Yutani, Ilia A. Kosenkov, Michael Milton  - extendr-macros 0.8.1: andy-thomason, Thomas Down, Mossa Merhi Reimert, Josiah Parry, Claus O. Wilke, Hiroaki Yutani, Ilia A. Kosenkov, Michael Milton  - foldhash 0.1.5: Orson Peters  - hashbrown 0.15.5: Amanieu d'Antras  - hashlink 0.10.0: kyren  - lazy_static 1.5.0: Marvin Löbel  - num-traits 0.2.19: The Rust Project Developers  - once_cell 1.21.3: Aleksey Kladov  - ordered-float 5.1.0: Jonathan Reem, Matt Brubeck  - paste 1.0.15: David Tolnay  - proc-macro2 1.0.103: David Tolnay, Alex Crichton  - quote 1.0.42: David Tolnay  - saphyr 0.0.6: Ethiraric, David Aguilar, Yuheng Chen  - saphyr-parser 0.0.6: Ethiraric, David Aguilar, Yuheng Chen  - syn 2.0.111: David Tolnay  - thiserror 2.0.17: David Tolnay  - thiserror-impl 2.0.17: David Tolnay  - unicode-ident 1.0.22: David Tolnay  (This file was auto-generated from 'cargo metadata' on 2025-12-02)"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"yaml12","dir":"","previous_headings":"","what":"Fast YAML 1.2 Parser and Formatter","title":"Fast YAML 1.2 Parser and Formatter","text":"YAML 1.2 parser/formatter R, implemented Rust speed correctness. Built excellent saphyr crate.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Fast YAML 1.2 Parser and Formatter","text":"can install yaml12 CRAN : can install development version yaml12 GitHub :","code":"install.packages(\"yaml12\") # install.packages(\"pak\") pak::pak(\"posit-dev/r-yaml12\")"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick start","title":"Fast YAML 1.2 Parser and Formatter","text":"","code":"library(yaml12)  yaml <- \" title: A modern YAML parser and emitter written in Rust properties: [fast, correct, safe, simple] sequences:   simplify: true \"  doc <- parse_yaml(yaml) str(doc) #> List of 3 #>  $ title     : chr \"A modern YAML parser and emitter written in Rust\" #>  $ properties: chr [1:4] \"fast\" \"correct\" \"safe\" \"simple\" #>  $ sequences :List of 1 #>   ..$ simplify: logi TRUE"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"reading-and-writing-files","dir":"","previous_headings":"Quick start","what":"Reading and writing files","title":"Fast YAML 1.2 Parser and Formatter","text":"","code":"value_out <- list(alpha = 1L, nested = c(TRUE, NA))  write_yaml(value_out, \"my.yaml\") value_in <- read_yaml(\"my.yaml\")  stopifnot(identical(value_out, value_in))  # Multi-document streams docs_out <- list(list(foo = 1L), list(bar = c(2L, NA)))  write_yaml(docs_out, \"my-multi.yaml\", multi = TRUE) docs_in <- read_yaml(\"my-multi.yaml\", multi = TRUE)  stopifnot(identical(docs_in, docs_out))"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"tag-handlers","dir":"","previous_headings":"Quick start","what":"Tag handlers","title":"Fast YAML 1.2 Parser and Formatter","text":"Handlers let opt custom behavior tagged nodes keeping default parser strict safe.","code":"yaml <- \" - !upper [rust, r] - !expr 6 * 7 \"  handlers <- list(   \"!expr\"  = function(x) eval(str2lang(x), baseenv()),   \"!upper\" = toupper )  parse_yaml(yaml, handlers = handlers) #> [[1]] #> [1] \"RUST\" \"R\"    #>  #> [[2]] #> [1] 42"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"non-string-mapping-keys","dir":"","previous_headings":"Quick start","what":"Non-string mapping keys","title":"Fast YAML 1.2 Parser and Formatter","text":"YAML mappings can use keys R store directly names (example, booleans, numbers, tagged strings). happens, parse_yaml() still returns named list also attaches yaml_keys attribute containing original YAML keys:","code":"yaml <- \" true: a null: b !custom foo: c \"  parsed <- parse_yaml(yaml)  stopifnot(identical(   parsed,   structure(     list(\"a\", \"b\", \"c\"),     names = c(\"\", \"\", \"\"),     yaml_keys = list(TRUE, NULL, structure(\"foo\", yaml_tag = \"!custom\"))   ) ))"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"formatting-and-round-tripping","dir":"","previous_headings":"Quick start","what":"Formatting and round-tripping","title":"Fast YAML 1.2 Parser and Formatter","text":"yaml_tag yaml_keys attributes also hooks customizing output: tags values round-trip, yaml_keys allows emit mappings non-string tagged keys can’t represented R name.","code":"obj <- list(   seq = 1:2,   map = list(key = \"value\"),   tagged = structure(\"1 + 1\", yaml_tag = \"!expr\"),   keys = structure(     list(\"a\", \"b\", \"c\"),     names = c(\"plain\", \"\", \"\"),     yaml_keys = list(\"plain\", TRUE, structure(\"foo\", yaml_tag = \"!custom\"))   ) )  yaml <- format_yaml(obj) cat(yaml) #> seq: #>   - 1 #>   - 2 #> map: #>   key: value #> tagged: !expr 1 + 1 #> keys: #>   plain: a #>   true: b #>   !custom foo: c  roundtripped <- parse_yaml(yaml) identical(obj, roundtripped) #> [1] TRUE"},{"path":"https://posit-dev.github.io/r-yaml12/dev/index.html","id":"documentation","dir":"","previous_headings":"","what":"Documentation","title":"Fast YAML 1.2 Parser and Formatter","text":"YAML quick primer: https://posit-dev.github.io/r-yaml12/articles/yaml-2-minute-intro.html. Tags, handlers, anchors, advanced YAML features: https://posit-dev.github.io/r-yaml12/articles/yaml-tags--advanced-features.html.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/format_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Format or write R objects as YAML 1.2. — format_yaml","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"format_yaml() returns YAML character string. write_yaml() writes YAML stream file stdout always emits document start (---) markers final end (...) marker. functions honor yaml_tag attribute values (see examples).","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/format_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"","code":"format_yaml(value, multi = FALSE)  write_yaml(value, path = NULL, multi = FALSE)"},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/format_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"value R object composed lists, atomic vectors, scalars. multi TRUE, treat value list YAML documents encode stream. path Scalar string file path write YAML using write_yaml(). NULL (default), write R's standard output connection.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/format_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"format_yaml() returns scalar character string containing YAML. write_yaml() invisibly returns value.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/format_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Format or write R objects as YAML 1.2. — format_yaml","text":"","code":"cat(format_yaml(list(foo = 1, bar = list(TRUE, NA)))) #> foo: 1 #> bar: #>   - true #>   - ~  docs <- list(\"first\", \"second\") cat(format_yaml(docs, multi = TRUE)) #> --- #> first #> --- #> second  tagged <- structure(\"1 + 1\", yaml_tag = \"!expr\") cat(tagged_yaml <- format_yaml(tagged), \"\\n\") #> !expr 1 + 1   dput(parse_yaml(tagged_yaml)) #> structure(\"1 + 1\", yaml_tag = \"!expr\")   write_yaml(list(foo = 1, bar = list(2, \"baz\"))) #> --- #> foo: 1 #> bar: #>   - 2 #>   - baz #> ...  write_yaml(list(\"foo\", \"bar\"), multi = TRUE) #> --- #> foo #> --- #> bar #> ...  tagged <- structure(\"1 + 1\", yaml_tag = \"!expr\") write_yaml(tagged) #> --- #> !expr 1 + 1 #> ..."},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"parse_yaml() takes strings YAML; read_yaml() reads file path.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"","code":"parse_yaml(text, multi = FALSE, simplify = TRUE, handlers = NULL)  read_yaml(path, multi = FALSE, simplify = TRUE, handlers = NULL)"},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"text Character vector; elements concatenated \"\\n\". multi TRUE, return list containing documents stream. simplify FALSE, keep YAML sequences R lists instead simplifying atomic vectors. handlers Named list R functions names corresponding YAML tags; matching handlers transform tagged values. path Scalar string path YAML file`.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"multi = FALSE, returns parsed R object first document. multi = TRUE, returns list parsed documents.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"YAML tags without corresponding handler preserved yaml_tag attribute. Mappings keys simple scalar strings returned named list yaml_keys attribute.","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/reference/parse_yaml.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse YAML 1.2 document(s) into base R structures. — parse_yaml","text":"","code":"dput(parse_yaml(\"foo: [1, 2, 3]\")) #> list(foo = 1:3)  # homogeneous sequences simplify by default. # YAML null maps to NA in otherwise homogeneous sequences. dput(parse_yaml(\"foo: [1, 2, 3, null]\")) #> list(foo = c(1L, 2L, 3L, NA))  # mixed type sequence never simplify dput(parse_yaml(\"[1, true, cat]\")) #> list(1L, TRUE, \"cat\")  # use `simplify=FALSE` to always return sequences as lists. str(parse_yaml(\"foo: [1, 2, 3, null]\", simplify = FALSE)) #> List of 1 #>  $ foo:List of 4 #>   ..$ : int 1 #>   ..$ : int 2 #>   ..$ : int 3 #>   ..$ : NULL  # Parse multiple documents when requested. stream <- \" --- first: 1 --- second: 2 \" str(parse_yaml(stream, multi = TRUE)) #> List of 2 #>  $ :List of 1 #>   ..$ first: int 1 #>  $ :List of 1 #>   ..$ second: int 2  # Read from a file; keep sequences as lists. path <- tempfile(fileext = \".yaml\") writeLines(\"alpha: [true, null]\\nbeta: 3.5\", path) str(read_yaml(path, simplify = FALSE)) #> List of 2 #>  $ alpha:List of 2 #>   ..$ : logi TRUE #>   ..$ : NULL #>  $ beta : num 3.5"},{"path":"https://posit-dev.github.io/r-yaml12/dev/news/index.html","id":"yaml12-development-version","dir":"Changelog","previous_headings":"","what":"yaml12 (development version)","title":"yaml12 (development version)","text":"Added benchmarks article comparing read/write performance yaml package (#2).","code":""},{"path":"https://posit-dev.github.io/r-yaml12/dev/news/index.html","id":"yaml12-010","dir":"Changelog","previous_headings":"","what":"yaml12 0.1.0","title":"yaml12 0.1.0","text":"CRAN release: 2025-12-11 Initial CRAN submission.","code":""}]
